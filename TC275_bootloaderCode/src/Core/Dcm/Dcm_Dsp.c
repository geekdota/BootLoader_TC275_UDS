/*============================================================================*/
/** Copyright (C) 2009-2018, 10086 INFRASTRUCTURE SOFTWARE CO.,LTD.
 *
 *  All rights reserved. This software is 10086 property. Duplication
 *  or disclosure without 10086 written authorization is prohibited.
 *
 *  @file       <Dcm_Dsp.c>
 *  @brief      <UDS Service - ISO14229>
 *
 *  <This Diagnostic Communication Manager file contained UDS services
 *   which used for bootloader project>
 *
 *  <Compiler: HighTec4.6    MCU:TC27x>
 *
 *  @author     <10086>
 *  @date       <2016-10-25>
 */
/*============================================================================*/

/*=======[R E V I S I O N   H I S T O R Y]====================================*/
/** <VERSION>  <DATE>  <AUTHOR>     <REVISION LOG>
 *    V1.0    20121109   10086       Initial version
 *
 *    V1.1    20160801  10086      update
 *
 *    V1.2    20180511  10086       update
 */
/*============================================================================*/

/*=======[I N C L U D E S]====================================================*/
#include "dcm_dsp.h"
#include "dcm_types.h"
#include "dcm_internel.h"
#include "appl.h"
#include "cantp.h"
#include "canif.h"
#include "FL.h"
#include "Dcm.h"
/*=======[T Y P E   D E F I N I T I O N S]====================================*/

#define WunusedParameter(a) \
    if (a != 0)             \
    { /* do mothing */      \
    } /* 10086 do */
/* data structure for program */
typedef struct
{
    /* data program start address */
    uint32 address;

    /* data program block Index(compare with parameter transfered by test) */
    uint8 blockId;

    /* if program condition is passed */
    boolean condition;

} Dcm_DspProgramType;

/* data structure for security access */
typedef struct
{
    /* DCM security access attempt num counter */
    uint8 attempt;
    /* if seed has requested */
    boolean seedReq;

    /* the last requested seed Id */
    uint8 seedIdReq;

    /* seed which generated by SecM module */
    SecM_SeedType seed;

} Dcm_DspSecurityType;

/*=======[I N T E R N A L   D A T A]==========================================*/
STATIC Dcm_DspProgramType dcmDspProgram;
STATIC Dcm_DspSecurityType dcmDspSec;
/* seed of last security access */
STATIC SecM_SeedType dcmLastSeed = 0UL;

/*=======[I N T E R N A L   F U N C T I O N   D E C L A R A T I O N S]========*/
STATIC uint32 Dcm_ConvertAddress(uint32 address);
STATIC uint32 Dcm_Get4Byte(const uint8 *data);
STATIC void Dcm_Set4Byte(uint8 *destData, const uint32 sourceData);

STATIC boolean Dcm_CheckSubFuncSession(const Dcm_SessionType sessionSupportMask);
STATIC boolean Dcm_CheckRoutineIDSession(const Dcm_SessionType sessionSupportMask);
STATIC boolean Dcm_CheckMsgLength(const uint16 standardlength, const uint16 receivedLength);
STATIC boolean Dcm_CheckSecurityCondition(const Dcm_SecurityType securitySupportMask);
STATIC boolean Dcm_CheckSubFuncFind(const boolean find, const Dcm_BuffType *rxBuff);

STATIC boolean Dcm_SessionChangeConditionCheck(Dcm_SessionType sessionValue);
STATIC boolean Dcm_ConditionCheck(void);
STATIC boolean Dcm_CheckReqOutOfRange(const boolean find);

STATIC boolean Dcm_HighVoltageCheck(void);
STATIC boolean Dcm_LowVoltageCheck(void);

STATIC void Dcm_RequestSeed(const Dcm_SecurityRowType *secTablePtr,
                            const Dcm_BuffType *rxBuff,
                            Dcm_BuffType *txBuff);
STATIC void Dcm_SendKey(const Dcm_SecurityRowType *secTablePtr,
                        const Dcm_BuffType *rxBuff,
                        Dcm_BuffType *txBuff);

/*=======[F U N C T I O N   I M P L E M E N T A T I O N S]====================*/

/******************************************************************************/
/**
 * @brief               <DCM module dsp initialize>
 *
 * <DCM module dsp initialize> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_DspInit(void)
{
    /* set program condition is allowed */
    dcmDspProgram.condition = TRUE;

    /* clear erase block id */
    dcmDspProgram.blockId = (uint8)0x00U;

    /* clear program address */
    dcmDspProgram.address = 0UL;

    /* clear security access attempt num */
    dcmDspSec.attempt = 0x00u;

    /* set seed has not requested */
    dcmDspSec.seedReq = FALSE;

    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x10 session control>
 *
 * <handle service 0x10 session control> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_RecvMsg10(const Dcm_BuffType *rxBuff, Dcm_BuffType *txBuff)
{
#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
    boolean positiveRspReq = TRUE;
#endif
    Dcm_SessionType sessionValue = (uint8)0x00u;
    uint8 sessionTableIndex = (uint8)DCM_SESSION_NUM;
    const Dcm_SessionRowType *sessionTablePtr = Dcm_SessionRow;
    boolean sessionFind = FALSE;
    boolean processContinue = TRUE;
    Dcm_SessionType curSession;
    uint8 subFunc;

    /*
     * convert subFunc to session mask value
     * default session:0x01->0x01
     * program session:0x02->0x02
     * extend session: 0x03->0x04
     */
    uint8 const sessionConvertTable[DCM_SESSION_SUPPORT_NUM] =
        {
            (uint8)DCM_SESSION_DEFAULT,
            (uint8)DCM_SESSION_PROGRAMMING,
            (uint8)DCM_SESSION_EXTEND};

    /* check if received message length is right, otherwise send NRC */
    processContinue = Dcm_CheckMsgLength(0x02u, rxBuff->pduInfo.SduLength);

    if (TRUE == processContinue)
    {
#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
        /* check if response is needed */
        if ((rxBuff->pduInfo.SduDataPtr[1] & DCM_RSP_NOT_REQUIRED) > 0x00u)
        {
            positiveRspReq = FALSE;
        }
#endif

        /* get sub function */
        subFunc = (rxBuff->pduInfo.SduDataPtr[1] & (uint8)DCM_RSP_CLEAR_REQUIRED);

        if ((subFunc > (uint8)DCM_SESSION_SUPPORT_NUM) || (subFunc < (uint8)DCM_SESSION_DEFAULT))
        {
            sessionFind = FALSE;
        }
        else
        {
            /* get sub function */
            sessionValue = sessionConvertTable[subFunc - 1u];

            /* find session mode sub function */
            while ((sessionTableIndex > (uint8)0) && (FALSE == sessionFind))
            {
                sessionTableIndex--;
                if (sessionValue == sessionTablePtr->sessionType)
                {
                    sessionFind = TRUE;
                }
                else
                {
                    sessionTablePtr++;
                }
            }
        }

        /* if did not find sub function, send NRC */
        processContinue = Dcm_CheckSubFuncFind(sessionFind, rxBuff);
    }
    else
    {
        /* empty */
    }

    if (TRUE == processContinue)
    {
        /* check if sub function is supported in current session, otherwise send NRC */
        processContinue = Dcm_CheckSubFuncSession(sessionTablePtr->sessionSupportMask);
    }
    else
    {
        /* empty */
    }

    /* SESSION_PROGRAMMING is not supported in function address */
    if (TRUE == processContinue)
    {
        if (((uint8)DCM_SESSION_PROGRAMMING == sessionValue) && ((uint16)DCM_RX_FUNC_PDU_ID == rxBuff->pduId))
        {
            /* subfunction is not supportted */
            Dcm_SendNcr(DCM_E_SUBFUNC_NOT_SUPPORTED);
            Dcm_ServiceFinish();
            processContinue = FALSE;
        }
        else
        {
            /* empty */
        }
    }
    else
    {
        /* empty */
    }

    if (TRUE == processContinue)
    {
        /* get current security level */
        curSession = Dcm_GetSessionMode();
        /* SESSION_DEFAULT is not supported to SESSION_PROGRAMMING*/
        if (((uint8)DCM_SESSION_DEFAULT == curSession) && ((uint8)DCM_SESSION_PROGRAMMING == sessionValue))
        {
            /* session change condition is not correct */
            Dcm_SendNcr(DCM_E_SUBFUNCTION_NOT_SUPPORT_IN_ACTIVE_SESSION);
            processContinue = FALSE;
        }
        /* SESSION_PROGRAMMING is not supported to SESSION_EXTEND*/
        else if (((uint8)DCM_SESSION_PROGRAMMING == curSession) && ((uint8)DCM_SESSION_EXTEND == sessionValue))
        {
            /* session change condition is not correct */
            Dcm_SendNcr(DCM_E_SUBFUNCTION_NOT_SUPPORT_IN_ACTIVE_SESSION);
            processContinue = FALSE;
        }
        else
        {
            /* empty */
        }
    }
    else
    {
        /* empty */
    }

#if (STD_ON == DCM_SID_NRC_SUPPORT)
    if (TRUE == processContinue)
    {
        /* check if subfunciton is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(sessionTablePtr->securitySupportMask);
    }
#endif

    if (TRUE == processContinue)
    {
        /* check if condition is correct, otherwise send NRC */
        processContinue = Dcm_SessionChangeConditionCheck(sessionValue);
    }
    else
    {
        /* empty */
    }

    if (TRUE == processContinue)
    {
        /* get current security level */
        curSession = Dcm_GetSessionMode();

        if (sessionValue != (uint8)DCM_SESSION_DEFAULT)
        {
            /* end the current send-key sequence */
            dcmDspSec.seedReq = FALSE;

            /* Initialize security level */
            Dcm_SetSecurityLevel(DCM_SECURITY_LOCKED);
        }
        else
        {
            /* empty */
        }

        /* if from non default session to default session, then not change, but reset */
        if ((((uint8)DCM_SESSION_PROGRAMMING == curSession) || ((uint8)DCM_SESSION_EXTEND == curSession)) && ((uint8)DCM_SESSION_DEFAULT == sessionValue) && (FALSE == dcmDummyDefault))
        {
            *(uint32 *)FL_BOOT_DEFAULT = (uint32)FL_BOOT_DEFAULT_FROM_PROG;
            /* force sending pending */
            Dcm_SendNcr(DCM_E_PENDING);
            CanTp_MainFunction();
            CanIf_MainFunction();
            /*ECU resrt*/
            Appl_EcuReset();
        }
        else
        {
            dcmDummyDefault = FALSE;
            Dcm_SetSessionMode(sessionValue);

#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
            if (TRUE == positiveRspReq)
            {
#endif
                /* set response message */
                txBuff->pduInfo.SduDataPtr[0] = (uint8)0x50u;
                txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
                txBuff->pduInfo.SduDataPtr[2] = (uint8)(((uint16)DCM_P2MAX_TIME) >> 0x08u);
                txBuff->pduInfo.SduDataPtr[3] = (uint8)DCM_P2MAX_TIME;
                txBuff->pduInfo.SduDataPtr[4] = (uint8)(((uint16)DCM_P2SMAX_TIME / (uint8)10) >> (uint8)0x08u);
                txBuff->pduInfo.SduDataPtr[5] = (uint8)(DCM_P2SMAX_TIME / 10);
                txBuff->pduInfo.SduLength = (uint8)0x06u;
                Dcm_SendRsp();
#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
            }
            else
            {
                /* reset service process */
                Dcm_ServiceFinish();
            }
#endif
        }
    }
    else
    {
        /* empty */
    }

    return;
}

#if (STD_ON == DCM_SERVICE_11_ENABLE)
/******************************************************************************/
/**
 * @brief               <handle service 0x11 ECU reset>
 *
 * <handle service 0x11 ECU reset> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_RecvMsg11(const Dcm_BuffType *rxBuff, Dcm_BuffType *txBuff)
{
#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
    boolean positiveRspReq = TRUE;
#endif
    Dcm_ResetType resetValue = (uint8)0;
    uint8 resetTableIndex = (uint8)DCM_RESET_NUM;
    const Dcm_ResetRowType *resetTablePtr = Dcm_ResetRow;
    boolean resetFind = FALSE;
    boolean processContinue = TRUE;

    /* check if the length of the message received is right, otherwise send NRC */
    processContinue = Dcm_CheckMsgLength(0x02u, rxBuff->pduInfo.SduLength);

    if (TRUE == processContinue)
    {
        /* get sub function */
        resetValue = (rxBuff->pduInfo.SduDataPtr[1] & (uint8)DCM_RSP_CLEAR_REQUIRED);

#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
        /* check if response is needed */
        if ((rxBuff->pduInfo.SduDataPtr[1] & DCM_RSP_NOT_REQUIRED) > 0x00u)
        {
            positiveRspReq = FALSE;
        }
        else
        {
            /* empty */
        }
#endif

        /* find reset mode sub function */
        while ((resetTableIndex > (uint8)0) && (FALSE == resetFind))
        {
            resetTableIndex--;
            if (resetValue == resetTablePtr->resetType)
            {
                resetFind = TRUE;
            }
            else
            {
                resetTablePtr++;
            }
        }

        /* if did not find sub function, send NRC */
        processContinue = Dcm_CheckSubFuncFind(resetFind, rxBuff);
    }
    else
    {
        /* empty */
    }

#if (STD_ON == DCM_SID_NRC_SUPPORT)
    if (TRUE == processContinue)
    {
        /* check if subfunciton is supportted in current session, other wise send NRC */
        processContinue = Dcm_CheckSubFuncSession(resetTablePtr->sessionSupportMask);
    }
#endif

#if (STD_ON == DCM_SID_NRC_SUPPORT)
    if (TRUE == processContinue)
    {
        /* check if subfunciton is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(resetTablePtr->securitySupportMask);
    }
#endif

    if (TRUE == processContinue)
    {
        /* check if condition is correct, otherwise send NRC */
        processContinue = Dcm_ConditionCheck();
    }
    else
    {
        /* empty */
    }

    if (TRUE == processContinue)
    {
#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
        if (TRUE == positiveRspReq)
        {
#endif

            /* set response message */
            txBuff->pduInfo.SduDataPtr[0] = (uint8)0x51u;
            txBuff->pduInfo.SduDataPtr[1] = resetValue;
            txBuff->pduInfo.SduLength = (uint8)0x02u;
            Dcm_SendRsp();

            Dcm_StartResetTimer(DCM_P2MAX_TIME);
#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
        }
        else
        {
            /* reset service process */
            Appl_EcuReset();
        }
#endif
    }
    else
    {
        /* empty */
    }

    return;
}
#endif

#if ((DCM_READDID_NUM > 0) && (STD_ON == DCM_SERVICE_22_ENABLE))
/******************************************************************************/
/**
 * @brief               <handle service 0x22 read data by identifier>
 *
 * <handle service 0x22 read data by identifier> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_RecvMsg22(const Dcm_BuffType *rxBuff, Dcm_BuffType *txBuff)
{
    uint16 readDid;
    uint8 readTableIndex = (uint8)DCM_READDID_NUM;
    const Dcm_ReadDidRowType *readTablePtr = Dcm_ReadDidRow;
    boolean didFind = FALSE;
    boolean processContinue = TRUE;
    uint16 readLength;

    /* check if the length of message received is right, otherwise send NRC */
    processContinue = Dcm_CheckMsgLength(0x03u, rxBuff->pduInfo.SduLength);

    if (TRUE == processContinue)
    {
        /* get read data Id */
        readDid = (uint16)(rxBuff->pduInfo.SduDataPtr[1] << (uint8)8);
        readDid += (uint16)rxBuff->pduInfo.SduDataPtr[2];

        /* find DID in configured read did table */
        while ((readTableIndex > (uint8)0) && (FALSE == didFind))
        {
            readTableIndex--;
            if (readDid == readTablePtr->DID)
            {
                didFind = TRUE;
            }
            else
            {
                readTablePtr++;
            }
        }

        /* if not find DID, send NRC */
        processContinue = Dcm_CheckReqOutOfRange(didFind);
    }
    else
    {
        /* empty */
    }

    if (TRUE == processContinue)
    {
        /* check if DID is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(readTablePtr->securitySupportMask);
    }

    if (TRUE == processContinue)
    {
        /* check if condition is correct, otherwise send NRC */
        processContinue = Dcm_ConditionCheck();
    }
    else
    {
        /* empty */
    }
    if (TRUE == processContinue)
    {
        /* execute read API, return read length */
        readLength = readTablePtr->readDataFct(&txBuff->pduInfo.SduDataPtr[3]);

        txBuff->pduInfo.SduDataPtr[0] = (uint8)0x62u;
        txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
        txBuff->pduInfo.SduDataPtr[2] = rxBuff->pduInfo.SduDataPtr[2];
        txBuff->pduInfo.SduLength = (uint16)0x03u + readLength;
        Dcm_SendRsp();
    }
    else
    {
        /* empty */
    }

    return;
}
#endif

/*****************************************************************************/
/**
 * @brief               <handle service 0x2E write data by identifier>
 *
 * <handle service 0x2E write data by identifier> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_RecvMsg2E(const Dcm_BuffType *rxBuff, Dcm_BuffType *txBuff)
{
    uint16 writeDid;
    uint8 writeTableIndex = (uint8)DCM_WRITEDID_NUM;
    const Dcm_WriteDidRowType *writeTablePtr = Dcm_WriteDidRow;
    boolean didFind = FALSE;
    boolean processContinue = TRUE;
    FL_ResultType writeRet;

    /* check if DID is supported in current security level, otherwise send NRC */
    processContinue = Dcm_CheckSecurityCondition(writeTablePtr->securitySupportMask);

    if (TRUE == processContinue)
    {
        /* get write data Id */
        writeDid = (uint16)(rxBuff->pduInfo.SduDataPtr[1] << (uint8)8);
        writeDid += (uint16)rxBuff->pduInfo.SduDataPtr[2];

        /* find write data Id in configured write data table */
        while ((writeTableIndex > (uint8)0) && (FALSE == didFind))
        {
            writeTableIndex--;
            if (writeDid == writeTablePtr->DID)
            {
                didFind = TRUE;
            }
            else
            {
                writeTablePtr++;
            }
        }

        /* if did not find DID, send NRC */
        processContinue = Dcm_CheckReqOutOfRange(didFind);
    }
    else
    {
        /* empty */
    }

    if (TRUE == processContinue)
    {
        /* check if the length of message received is right, otherwise send NRC */
        processContinue = Dcm_CheckMsgLength(writeTablePtr->dataLength + (uint8)0x03u,
                                             rxBuff->pduInfo.SduLength);
    }
    else
    {
        /* empty */
    }

    if (TRUE == processContinue)
    {
        processContinue = Dcm_CheckSessionSuppMask_2E(writeTablePtr->securitySupportMask);
    }
    else
    {
        /* empty */
    }

    if (TRUE == processContinue)
    {
        /* check if DID is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(writeTablePtr->securitySupportMask);
    }

    if (TRUE == processContinue)
    {
        /* check if condition is correct, other wise send NRC */
        processContinue = Dcm_ConditionCheck();
    }

    if (TRUE == processContinue)
    {
        /* execute write API, return read length */
        writeRet = writeTablePtr->writeDataFct(&rxBuff->pduInfo.SduDataPtr[3],
                                               writeTablePtr->dataLength);

        /* check if FL step is correct, otherwise send NRC */
        if ((uint8)FL_ERR_SEQUENCE == writeRet)
        {
            Dcm_SendNcr(DCM_E_REQUEST_SEQUENCE_ERROR);
        }
        else
        {
            /* if write data accepted, wait for write pending */
            if (writeRet != (uint8)FL_OK)
            {
                /* program finger print failure */
                Dcm_SendNcr(DCM_E_GENERAL_PROGRAMMING_FAILURE);
            }
            else
            {
                /* empty */
            }
        }
    }
    else
    {
        /* empty */
    }
    WunusedParameter(txBuff) /* 10086 do */
        return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x27 security access>
 *
 * <handle service 0x27 security access> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_RecvMsg27(const Dcm_BuffType *rxBuff, Dcm_BuffType *txBuff)
{
    const Dcm_SessionType secId = rxBuff->pduInfo.SduDataPtr[1];
    uint8 secTableIndex = (uint8)DCM_SECURITY_NUM;
    const Dcm_SecurityRowType *secTablePtr = Dcm_SecurityRow;
    boolean secIdFind = FALSE;
    boolean processContinue = TRUE;
    uint16 checkLength;
    boolean secDelayTime;

    /* find sub function Id in configured security table */
    while ((secTableIndex > (uint8)0) && (FALSE == secIdFind))
    {
        secTableIndex--;
        if ((secId == secTablePtr->reqSeedId) || (secId == secTablePtr->sendKeyId))
        {
            secIdFind = TRUE;
        }
        else
        {
            secTablePtr++;
        }
    }

    /* if did not find sub function, send NRC */
    processContinue = Dcm_CheckSubFuncFind(secIdFind, rxBuff);

#if (STD_ON == DCM_SID_NRC_SUPPORT)
    if (TRUE == processContinue)
    {
        /* check if subfunciton is supportted in current session, other wise send NRC */
        processContinue = Dcm_CheckSubFuncSession(secTablePtr->sessionSupportMask);
    }
#endif

    if (TRUE == processContinue)
    {
        if (secId == secTablePtr->reqSeedId)
        {
            checkLength = (uint16)0x02u;
        }
        else
        {
            checkLength = (uint16)0x06u;
        }

        /* check if the length of message received is right, otherwise send NRC */
        processContinue = Dcm_CheckMsgLength(checkLength, rxBuff->pduInfo.SduLength);
    }
    else
    {
        /* empty */
    }

#if (STD_ON == DCM_SID_NRC_SUPPORT)
    if (TRUE == processContinue)
    {
        /* check if subfunction is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(secTablePtr->securitySupportMask);
    }
#endif

    if (TRUE == processContinue)
    {
        /* check if condition is correct, other wise send NRC */
        processContinue = Dcm_ConditionCheck();
    }

    if (TRUE == processContinue)
    {
        secDelayTime = Dcm_GetSecurityTimerExpired();
        /* check if security timer is expired */
        if (FALSE == secDelayTime)
        {
            /* security access timer delay is not expired */
            Dcm_SendNcr(DCM_E_REQUIRED_TIME_DELAY_NOT_EXPIRED);
        }
        else
        {
            if (secId == secTablePtr->reqSeedId)
            {
                Dcm_RequestSeed(secTablePtr, rxBuff, txBuff);
            }
            else
            {
                Dcm_SendKey(secTablePtr, rxBuff, txBuff);
            }
        }
    }
    else
    {
        /* empty */
    }

    return;
}

#if (DCM_COM_CONTROL_NUM > 0)
/******************************************************************************/
/**
 * @brief               <handle service 0x28 communication control>
 *
 * <handle service 0x28 communication control> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_RecvMsg28(const Dcm_BuffType *rxBuff, Dcm_BuffType *txBuff)
{
#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
    boolean positiveRspReq = TRUE;
#endif
    const Dcm_ComControlType controlValue = rxBuff->pduInfo.SduDataPtr[1];
    uint8 comTableIndex = (uint8)DCM_COM_CONTROL_NUM;
    const Dcm_ComControlRowType *comTablePtr = Dcm_ComControlRow;
    boolean controlTypeFind = FALSE;
    boolean processContinue = TRUE;
    Dcm_CommunicationType communicationType;

#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
    /* check if response is needed */
    if ((rxBuff->pduInfo.SduDataPtr[1] & DCM_RSP_NOT_REQUIRED) > 0x00u)
    {
        positiveRspReq = FALSE;
    }
    else
    {
        /* empty */
    }
#endif
    /* check if the length of message received is right, otherwise send NRC */
    processContinue = Dcm_CheckMsgLength(0x03u, rxBuff->pduInfo.SduLength);

    if (TRUE == processContinue)
    {
        /* find communication control type in configured table */
        while ((comTableIndex > (uint8)0) && (FALSE == controlTypeFind))
        {
            comTableIndex--;

            if (controlValue == comTablePtr->controlType)
            {
                controlTypeFind = TRUE;
            }
            else
            {
                comTablePtr++;
            }
        }

        /* if did not find sub funciton, send NRC */
        processContinue = Dcm_CheckSubFuncFind(controlTypeFind, rxBuff);
    }
    else
    {
        /* empty */
    }

#if (STD_ON == DCM_SID_NRC_SUPPORT)
    if (TRUE == processContinue)
    {
        /* check if subfunciton is supportted in current session, other wise send NRC */
        processContinue = Dcm_CheckSubFuncSession(comTablePtr->sessionSupportMask);
    }
#endif

#if (STD_ON == DCM_SID_NRC_SUPPORT)
    if (TRUE == processContinue)
    {
        /* check if subfunction is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(comTablePtr->securitySupportMask);
    }
#endif

    if (TRUE == processContinue)
    {
        /* check if condition is correct, other wise send NRC */
        processContinue = Dcm_ConditionCheck();
    }

    if (TRUE == processContinue)
    {
        communicationType = rxBuff->pduInfo.SduDataPtr[2];

        /* check if communication type is correct */
        if ((uint8)DCM_NORMAL_COM_MESSAGES == communicationType)
        {
            if ((DCM_DISABLE_RXANDTX == controlValue) && (0 == FunctService255))
            {
                FunctService255 = 1;
            }
            else
            {
#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
                if (TRUE == positiveRspReq)
                {
#endif
                    /* set response message */
                    txBuff->pduInfo.SduDataPtr[0] = (uint8)0x68u;
                    txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
                    txBuff->pduInfo.SduLength = (uint8)0x02u;
                    Dcm_SendRsp();
#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
                }
                else
                {
                    /* reset service process */
                    Dcm_ServiceFinish();
                }
#endif
            }
        }
        else
        {
            /* Request out of range */
            Dcm_SendNcr(DCM_E_REQUEST_OUT_OF_RANGE);
        }
    }
    else
    {
        /* empty */
    }

    return;
}
#endif

/******************************************************************************/
/**
 * @brief               <handle service 0x34 request download>
 *
 * <handle service 0x34 request download> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>
 */
/******************************************************************************************/
void Dcm_RecvMsg34(const Dcm_BuffType *rxBuff, Dcm_BuffType *txBuff)
{
    boolean processContinue = TRUE;
    uint32 programSize;
    FL_ResultType requestRet;
    uint8 formatId;
    uint8 dataFormat;

    /* check if the length of message received is right, otherwise send NRC */
    processContinue = Dcm_CheckMsgLength((uint16)11, rxBuff->pduInfo.SduLength);

    if (TRUE == processContinue)
    {
        /* check if service is supported in current security level, otherwise send NRC */
        processContinue = Dcm_CheckSecurityCondition(Dcm_DownloadRow.securitySupportMask);
    }
    else
    {
        /* empty */
    }

    if (TRUE == processContinue)
    {
        formatId = rxBuff->pduInfo.SduDataPtr[1];
        dataFormat = rxBuff->pduInfo.SduDataPtr[2];

        /* check if format Id and data format is correct */
        if (((uint8)0x00u == formatId) && ((uint8)0x44u == dataFormat))
        {
            /* set program index to 0, for service 0x36 */
            dcmDspProgram.blockId = (uint8)0x00u;

            /* get program address */
            dcmDspProgram.address = Dcm_Get4Byte(&rxBuff->pduInfo.SduDataPtr[3]);
            if (0UL == dcmDspProgram.address)
            {
                dcmDspProgram.address = FL_DEV_BASE_ADDRESS;
            }
            else
            {
                /* empty */
            }
            /* convert address format */
            dcmDspProgram.address = Dcm_ConvertAddress(dcmDspProgram.address);

            /* get program length */
            programSize = Dcm_Get4Byte(&rxBuff->pduInfo.SduDataPtr[7]);

            /* check if program address and length is correct */
            requestRet = FL_DownloadRequestValid(dcmDspProgram.address, programSize);

            if ((uint8)FL_OK == requestRet)
            {
                /* set response message */
                txBuff->pduInfo.SduDataPtr[0] = (uint8)0x74u;
                txBuff->pduInfo.SduDataPtr[1] = (uint8)0x20u;
                txBuff->pduInfo.SduDataPtr[2] = (uint8)(DCM_RX_BUF_SIZE >> (uint8)8);
                txBuff->pduInfo.SduDataPtr[3] = (uint8)DCM_RX_BUF_SIZE;
                txBuff->pduInfo.SduLength = (uint8)0x04u;
                Dcm_SendRsp();
            }
            else if ((uint8)FL_ERR_SEQUENCE == requestRet)
            {
                /* 0x34, 0x36, 0x37 service sequence is not correct */
                Dcm_SendNcr((uint8)DCM_E_CONDITIONS_NOT_CORRECT);
            }
            else if ((uint8)FL_NO_FLASHDRIVER == requestRet)
            {
                Dcm_SendNcr((uint8)DCM_E_REQUEST_OUT_OF_RANGE);
            }
            else if ((uint8)FL_NO_FINGERPRINT == requestRet)
            {
                /* finger print is not written */
                Dcm_SendNcr((uint8)DCM_E_UPLOAD_DOWNLOAD_NOT_ACCEPTED);
            }
            else
            {
                /* Request out of range */
                Dcm_SendNcr((uint8)DCM_E_REQUEST_OUT_OF_RANGE);
            }
        }
        else
        {
            /* Request out of range */
            Dcm_SendNcr((uint8)DCM_E_REQUEST_OUT_OF_RANGE);
        }
    }
    else
    {
        /* empty */
    }

    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x36 transfer data>
 *
 * <handle service 0x36 transfer data> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_RecvMsg36(const Dcm_BuffType *rxBuff, Dcm_BuffType *txBuff)
{
    boolean processContinue = TRUE;
    uint32 programSize;
    FL_ResultType programRet;
    uint8 dataBlockId = (uint8)0;

    /* check if the length of message received is right, otherwise send NRC */
    if (rxBuff->pduInfo.SduLength < (uint16)3)
    {
        processContinue = FALSE;
        Dcm_SendNcr(DCM_E_INCORRECT_MESSAGE_LENGTH);
    }
    else
    {
        processContinue = TRUE;
    }

    if (TRUE == processContinue)
    {
        /* check if service is supportted in current security level, other wise send NRC */
        processContinue = Dcm_CheckSecurityCondition(Dcm_DownloadRow.securitySupportMask);
    }
    else
    {
        /*empty*/
    }

    if (TRUE == processContinue)
    {
        /* check if voltage is too high, send NRC */
        processContinue = Dcm_HighVoltageCheck();
    }
    else
    {
        /*empty*/
    }

    if (TRUE == processContinue)
    {
        /* check if voltage is too high, send NRC */
        processContinue = Dcm_LowVoltageCheck();
    }
    else
    {
        /*empty*/
    }

    if (TRUE == processContinue)
    {
        /* get program block index */
        dataBlockId = rxBuff->pduInfo.SduDataPtr[1];
        /* receive the same dataBlockId again */
        if (dcmDspProgram.blockId == dataBlockId)
        {
            txBuff->pduInfo.SduDataPtr[0] = (uint8)0x76u;
            txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
            txBuff->pduInfo.SduLength = (uint8)0x02u;
            Dcm_SendRsp();
            processContinue = FALSE;
        }
        else
        {
            /* empty */
        }
    }
    else
    {
        /* empty */
    }

    if (TRUE == processContinue)
    {
        /* index programmed block index */
        if ((uint8)0xFFU == dcmDspProgram.blockId)
        {
            dcmDspProgram.blockId = (uint8)0;
        }
        else
        {
            dcmDspProgram.blockId++;
        }

        if (dcmDspProgram.blockId != dataBlockId)
        {
            /* program block index is not correct */
            Dcm_SendNcr(DCM_E_WRONG_BLOCK_SEQUENCE_COUNTER);
        }
        else
        {
            programSize = (uint32)(rxBuff->pduInfo.SduLength - (uint8)2);

            /* execute program routine */
            programRet = FL_FlashProgramRegion(dcmDspProgram.address,
                                               &rxBuff->pduInfo.SduDataPtr[2],
                                               programSize);
            /* index program address */
            dcmDspProgram.address += programSize;

            if ((uint8)FL_ERR_SEQUENCE == programRet)
            {
                /* 0x34,0x36,0x37 service sequence is not correct */
                Dcm_SendNcr(DCM_E_REQUEST_SEQUENCE_ERROR);
            }
            else if ((uint8)FL_ERR_ADDR_LENGTH == programRet)
            {
                /* program length is not the same as received in 0x34 service */
                Dcm_SendNcr(DCM_E_TRANSFER_DATA_SUSPENDED);
            }
            else
            {
                /* wait for pending */
            }
        }
    }
    else
    {
        /* empty */
    }

    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x37 exit transfer data>
 *
 * <handle service 0x37 exit transfer data> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_RecvMsg37(const Dcm_BuffType *rxBuff, Dcm_BuffType *txBuff)
{
    boolean processContinue = TRUE;
    FL_ResultType programRet;

    /* check if the length of message received is right, otherwise send NRC */
    processContinue = Dcm_CheckMsgLength(0x01u, rxBuff->pduInfo.SduLength);

    if (TRUE == processContinue)
    {
        /* execute transfer data exit */
        programRet = FL_ExitTransferData();

        if ((uint8)FL_OK == programRet)
        {
            dcmDspProgram.blockId = (uint8)0x00U;

            /* set response message */
            txBuff->pduInfo.SduDataPtr[0] = (uint8)0x77u;
            txBuff->pduInfo.SduLength = (uint8)0x01u;
            Dcm_SendRsp();
        }
        else
        {
            /* 0x34, 0x36, 0x37 service sequence is not correct */
            Dcm_SendNcr(DCM_E_REQUEST_SEQUENCE_ERROR);
        }
    }
    else
    {
        /* empty */
    }

    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x31 routine control>
 *
 * <handle service 0x31 routine control> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_RecvMsg31(const Dcm_BuffType *rxBuff, Dcm_BuffType *txBuff)
{
    boolean processContinue = TRUE;
    uint16 routineIdValue;
    const Dcm_RoutineControlRowType *routineTablePtr = Dcm_RoutineControlRow;
    uint8 routineTableIndex;
    boolean routineIdFind;

    /* get routine control type */
    const uint8 routineControlValue = rxBuff->pduInfo.SduDataPtr[1];
    /* check min length */
    if (DCM_UDS31_MIN_LENGTH > rxBuff->pduInfo.SduLength)
    {
        processContinue = FALSE;
        /* min length is not correct,send NRC0x13 */
        Dcm_SendNcr(DCM_E_INCORRECT_MESSAGE_LENGTH);
    }
    if (TRUE == processContinue)
    {
        routineTableIndex = (uint8)DCM_ROUTINE_CONTROL_NUM;
        routineIdFind = FALSE;

        /* get routine Id */
        routineIdValue = (uint16)(rxBuff->pduInfo.SduDataPtr[2] << (uint8)8);
        routineIdValue += (uint16)rxBuff->pduInfo.SduDataPtr[3];

        /* find routine Id in routine table */
        while ((routineTableIndex > (uint8)0) && (FALSE == routineIdFind))
        {
            routineTableIndex--;
            if ((routineIdValue == routineTablePtr->routineId) && (((uint16)DCM_RX_PHY_PDU_ID == rxBuff->pduId) || (((uint16)DCM_RX_FUNC_PDU_ID == rxBuff->pduId) && (TRUE == routineTablePtr->funcAddrSupp))))
            {
                routineIdFind = TRUE;
            }
            else
            {
                routineTablePtr++;
            }
        }

        /* if routine Id is not find, send NRC31 */
        processContinue = Dcm_CheckReqOutOfRange(routineIdFind);
    }
    else
    {
        /* empty */
    }
    if (TRUE == processContinue)
    {
        /* check if RoutineID is supported in current session, otherwise send NRC31 */
        processContinue = Dcm_CheckRoutineIDSession(routineTablePtr->sessionSupportMask);
    }
    else
    {
        /* empty */
    }
    if (TRUE == processContinue)
    {
        /* check if sub function is supported in current security level, otherwise send NRC33 */
        processContinue = Dcm_CheckSecurityCondition(routineTablePtr->securitySupportMask);
    }
    else
    {
        /* empty */
    }
    if (TRUE == processContinue)
    {
        /* check if sub function is start routine */
        if (routineControlValue != (uint8)DCM_START_ROUTINE)
        {
            /* sub function is not supported,send NRC0x12 */
            processContinue = Dcm_CheckSubFuncFind(FALSE, rxBuff);
        }
        else
        {
            /* empty */
        }
    }

    if (TRUE == processContinue)
    {
        /* check if the length of message received is right, otherwise send NRC0x13*/
        processContinue = Dcm_CheckMsgLength((uint16)((uint8)4 + routineTablePtr->optionLength),
                                             rxBuff->pduInfo.SduLength);
    }
    else
    {
        /* empty */
    }

    if (TRUE == processContinue)
    {
        /* set response message */
        txBuff->pduInfo.SduDataPtr[0] = (uint8)0x71u;
        txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
        txBuff->pduInfo.SduDataPtr[2] = rxBuff->pduInfo.SduDataPtr[2];
        txBuff->pduInfo.SduDataPtr[3] = rxBuff->pduInfo.SduDataPtr[3];

        /* execute routine */
        routineTablePtr->routineControl(rxBuff, txBuff);
    }
    else
    {
        /* empty */
    }

    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x31 check program pre-condition>
 *
 * <handle service 0x31 check program pre-condition> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_CheckProgPreCondition(const Dcm_BuffType *rxBuff,
                               Dcm_BuffType *txBuff)
{
    uint8 conditionLength;
    if (Dcm_GetSessionMode() != DCM_SESSION_EXTEND)
    {
        Dcm_SendNcr(DCM_E_SERVICE_NOT_SUPPORTED_IN_ACTIVE_SESSION);
    }
    else
    {
        /* execute routine for check programming pre-conditions */
        conditionLength = FL_CheckProgPreCondition(&txBuff->pduInfo.SduDataPtr[4]);

        if ((uint8)0 == conditionLength)
        {
            /* programming pre-conditions is accepted */
            dcmDspProgram.condition = TRUE;
        }
        else
        {
            /* programming pre-conditions is not accepted */
            dcmDspProgram.condition = FALSE;
        }

        /* set response message */
        txBuff->pduInfo.SduLength = (uint16)(conditionLength + (uint16)0x05u);
        Dcm_SendRsp();
    }
    WunusedParameter(rxBuff) /* 10086 do */
        return;
}
/******************************************************************************/
/**
 * @brief               <handle service 0x31 check dependency>
 *
 * <handle service 0x31 check dependency> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_CheckProgDependencies(const Dcm_BuffType *rxBuff, Dcm_BuffType *txBuff)
{
    FL_ResultType consistencyStatus;

    /* execute routine for check application software dependency */
    consistencyStatus = Appl_CheckConsistency();

    /* set response message */
    if ((uint8)FL_OK == consistencyStatus)
    {
        /* send NRC78 */
        Dcm_SendNcr(DCM_E_PENDING);
        CanTp_MainFunction();
        CanIf_MainFunction();

        txBuff->pduInfo.SduDataPtr[4] = (uint8)0x00u;

        /* if OK, let pending31() response, not here */
        FL_updateProgCnt();
    }
    else
    {
        txBuff->pduInfo.SduDataPtr[4] = (uint8)0x01u;
        txBuff->pduInfo.SduLength = (uint8)0x05u;

        Dcm_SendRsp();
    }
    WunusedParameter(rxBuff) /* 10086 do */
        return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x31 checksum>
 *
 * <handle service 0x31 checksum> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_CheckMemory(const Dcm_BuffType *rxBuff, Dcm_BuffType *txBuff)
{
    FL_ResultType checksumRet;

    /* execute checksum routine */
    checksumRet = FL_CheckSumRoutine(&rxBuff->pduInfo.SduDataPtr[4]);

    if ((uint8)FL_OK == checksumRet)
    {
        /* send NRC78 */
        Dcm_SendNcr(DCM_E_PENDING);
        CanTp_MainFunction();
        CanIf_MainFunction();
    }
    else if ((uint8)FL_ERR_SEQUENCE == checksumRet)
    {
        /* checksum sequence error, no finger print or download data */
        Dcm_SendNcr(DCM_E_REQUEST_SEQUENCE_ERROR);
    }
    else
    {
        Dcm_SendNcr(DCM_E_CONDITIONS_NOT_CORRECT);
    }
    WunusedParameter(txBuff) /* 10086 do */
        return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x31 erase block>
 *
 * <handle service 0x31 erase block> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_EraseMemory(const Dcm_BuffType *rxBuff, Dcm_BuffType *txBuff)
{
    FL_ResultType eraseRet = (uint8)FL_INVALID_DATA;
    uint8 parameterLen;
    uint32 eraseAddress;
    uint32 eraseLength;
    uint8 index;

    parameterLen = rxBuff->pduInfo.SduDataPtr[4];
    eraseAddress = Dcm_Get4Byte(&rxBuff->pduInfo.SduDataPtr[5]);
    /* convert address format */
    eraseAddress = Dcm_ConvertAddress(eraseAddress);
    eraseLength = Dcm_Get4Byte(&rxBuff->pduInfo.SduDataPtr[9]);

    if ((uint8)0x44u == parameterLen)
    {
        for (index = (uint8)0; index < FL_NUM_LOGICAL_BLOCKS; index++)
        {
            if ((eraseAddress == FL_BlkInfo[index].address) && (eraseLength <= FL_BlkInfo[index].length))
            {
                /* execute erase routine */
                eraseRet = FL_EraseRoutine(index);
            }
            else
            {
                /* empty */
            }
        }

        if ((uint8)FL_OK == eraseRet)
        {
            /* send NRC78 */
            Dcm_SendNcr(DCM_E_PENDING);
            CanTp_MainFunction();
            CanIf_MainFunction();
        }
        else if (((uint8)FL_NO_FINGERPRINT == eraseRet) || ((uint8)FL_ERR_SEQUENCE == eraseRet) || ((uint8)FL_NO_FLASHDRIVER == eraseRet))
        {
            /* erase sequence error, no finger print or download data */
            Dcm_SendNcr(DCM_E_REQUEST_SEQUENCE_ERROR);
        }
        else if ((uint8)FL_INVALID_DATA == eraseRet)
        {
            Dcm_SendNcr(DCM_E_REQUEST_OUT_OF_RANGE);
        }
        else
        {
            /* FL_FAILED == eraseRet */
            Dcm_SendNcr(DCM_E_GENERAL_PROGRAMMING_FAILURE);
        }
    }
    else
    {
        Dcm_SendNcr(DCM_E_REQUEST_OUT_OF_RANGE);
    }
    WunusedParameter(txBuff) /* 10086 do */
        return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x3E test precent>
 *
 * <handle service 0x3E test present> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_RecvMsg3E(const Dcm_BuffType *rxBuff, Dcm_BuffType *txBuff)
{
#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
    boolean positiveRspReq = TRUE;
#endif
    boolean processContinue = TRUE;
    boolean testPresentFind = FALSE;
    uint8 testPresentTableIndex = (uint8)DCM_TESTPRESENT_NUM;
    const uint8 subFunc = (rxBuff->pduInfo.SduDataPtr[1] & (uint8)DCM_RSP_CLEAR_REQUIRED);
    const Dcm_testPresentRowType *testPresentTablePtr = Dcm_testPresentRow;

    /* check if the length of message received is right, otherwise send NRC */
    processContinue = Dcm_CheckMsgLength(0x02u, rxBuff->pduInfo.SduLength);

    if (TRUE == processContinue)
    {
#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
        /* check if response is needed */
        if ((rxBuff->pduInfo.SduDataPtr[1] & DCM_RSP_NOT_REQUIRED) > 0x00u)
        {
            positiveRspReq = FALSE;
        }
        else
        {
            /* empty */
        }
#endif

        /* find test present sub function */
        while ((testPresentTableIndex > (uint8)0) && (FALSE == testPresentFind))
        {
            testPresentTableIndex--;
            if (subFunc == testPresentTablePtr->zeroSubFunc)
            {
                testPresentFind = TRUE;
            }
            else
            {
                testPresentTablePtr++;
            }
        }

        /* if did not find sub function, send NRC */
        processContinue = Dcm_CheckSubFuncFind(testPresentFind, rxBuff);
    }
    else
    {
        /* empty */
    }

    if (TRUE == processContinue)
    {
#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
        if (TRUE == positiveRspReq)
        {
#endif
            /* set response message */
            txBuff->pduInfo.SduDataPtr[0] = (uint8)0x7Eu;
            txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
            txBuff->pduInfo.SduLength = (uint8)0x02u;
            Dcm_SendRsp();
#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
        }
        else
        {
            /* reset service process */
            Dcm_ServiceFinish();
        }
#endif
    }
    else
    {
        /* empty */
    }

    return;
}

#if (DCM_DTC_SET_NUM > 0)
/******************************************************************************/
/**
 * @brief               <handle service 0x85 set DTC control>
 *
 * <handle service 0x85 set DTC control> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_RecvMsg85(const Dcm_BuffType *rxBuff, Dcm_BuffType *txBuff)
{
#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
    boolean positiveRspReq = TRUE;
#endif
    Dcm_DTCSettingType DTCsetType;
    uint8 DTCsetTableIndex = (uint8)DCM_DTC_SET_NUM;
    const Dcm_DTCSettingRowType *DTCsetTablePtr = Dcm_DTCSettingRow;
    boolean DTCsetTypeFind = FALSE;
    boolean processContinue = TRUE;

    /* check if the length of message received is right, otherwise send NRC */
    processContinue = Dcm_CheckMsgLength(0x02u, rxBuff->pduInfo.SduLength);

    if (TRUE == processContinue)
    {
        /* get sub function */
        DTCsetType = (rxBuff->pduInfo.SduDataPtr[1] & DCM_RSP_CLEAR_REQUIRED);

#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
        /* check if response is needed */
        if ((rxBuff->pduInfo.SduDataPtr[1] & (uint8)DCM_RSP_NOT_REQUIRED) > (uint8)0)
        {
            positiveRspReq = FALSE;
        }
        else
        {
            /* empty */
        }
#endif

        /* find DTC setting sub function */
        while ((DTCsetTableIndex > (uint8)0) && (FALSE == DTCsetTypeFind))
        {
            DTCsetTableIndex--;
            if (DTCsetType == DTCsetTablePtr->DTCSet)
            {
                DTCsetTypeFind = TRUE;
            }
            else
            {
                DTCsetTablePtr++;
            }
        }

        /* if did not find sub function, send NRC */
        processContinue = Dcm_CheckSubFuncFind(DTCsetTypeFind, rxBuff);
    }
    else
    {
        /* empty */
    }

    if (TRUE == processContinue)
    {
        /* check if condition is correct, otherwise send NRC */
        processContinue = Dcm_ConditionCheck();
    }
    else
    {
        /* empty */
    }

    if (TRUE == processContinue)
    {
        processContinue = Dcm_CheckSessionSuppMask(DTCsetTablePtr->sessionSupportMask);
    }
    else
    {
        /* empty */
    }

    if (TRUE == processContinue)
    {
#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
        if (TRUE == positiveRspReq)
        {
#endif
            /* set response message */
            txBuff->pduInfo.SduDataPtr[0] = (uint8)0xC5u;
            txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
            txBuff->pduInfo.SduLength = (uint8)0x02u;
            Dcm_SendRsp();
#if (STD_ON == DCM_SUPPRESS_POS_SUPPORT)
        }
        else
        {
            /* reset service process */
            Dcm_ServiceFinish();
        }
#endif
    }
    else
    {
        /* empty */
    }

    return;
}
#endif

/******************************************************************************/
/**
 * @brief               <handle service 0x2E write data pending finish>
 *
 * <handle service 0x2E write data pending finish> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <errorCode (IN),rxBuff (IN),>
 * @param[out]          <NONE>
 * @param[in/out]       <txBuff (IN/OUT)>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_Pending2E(const FL_ResultType errorCode,
                   const Dcm_BuffType *rxBuff,
                   Dcm_BuffType *txBuff)
{
    /* check if write data successful */
    if ((uint8)FL_OK == errorCode)
    {
        txBuff->pduInfo.SduDataPtr[0] = (uint8)0x6Eu;
        txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
        txBuff->pduInfo.SduDataPtr[2] = rxBuff->pduInfo.SduDataPtr[2];
        txBuff->pduInfo.SduLength = (uint8)0x03u;
        Dcm_SendRsp();
    }
    else
    {
        /* program finger print failure */
        Dcm_SendNcr(DCM_E_GENERAL_PROGRAMMING_FAILURE);
    }

    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x36 transfer data pending finish>
 *
 * <handle service 0x36 transfer data pending finish> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <errorCode (IN),rxBuff (IN),>
 * @param[out]          <NONE>
 * @param[in/out]       <txBuff (IN/OUT)>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_Pending36(const FL_ResultType errorCode,
                   const Dcm_BuffType *rxBuff,
                   Dcm_BuffType *txBuff)
{
    /* check if program data successful */
    if ((uint8)FL_OK == errorCode)
    {
        txBuff->pduInfo.SduDataPtr[0] = (uint8)0x76u;
        txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
        txBuff->pduInfo.SduLength = (uint8)0x02u;
        Dcm_SendRsp();
    }
    else
    {
        /* program data failure */
        Dcm_SendNcr(DCM_E_GENERAL_PROGRAMMING_FAILURE);
    }

    return;
}

/******************************************************************************/
/**
 * @brief               <handle service 0x31 routine control pending finish>
 *
 * <handle service 0x31 routine control pending finish> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <errorCode (IN),rxBuff (IN),>
 * @param[out]          <NONE>
 * @param[in/out]       <txBuff (IN/OUT)>
 * @return              <NONE>
 */
/******************************************************************************/
void Dcm_Pending31(const FL_ResultType errorCode, const Dcm_BuffType *rxBuff,
                   Dcm_BuffType *txBuff)
{
    /* check if execute routine successful */
    if ((uint8)FL_OK == errorCode)
    {
        txBuff->pduInfo.SduDataPtr[4] = (uint8)0x00u;
    }
    else
    {
        /* execute routine failure */
        txBuff->pduInfo.SduDataPtr[4] = (uint8)0x01u;
    }

    txBuff->pduInfo.SduDataPtr[0] = (uint8)0x71u;
    txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
    txBuff->pduInfo.SduDataPtr[2] = rxBuff->pduInfo.SduDataPtr[2];
    txBuff->pduInfo.SduDataPtr[3] = rxBuff->pduInfo.SduDataPtr[3];
    txBuff->pduInfo.SduLength = (uint8)0x05u;
    Dcm_SendRsp();

    return;
}

/******************************************************************************/
/**
 * @brief               <convert address 0x8xxxxxxx to 0xaxxxxxxx for TC27x Platform>
 *
 * <> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <NONE>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <NONE>
 */
/******************************************************************************/
STATIC uint32 Dcm_ConvertAddress(uint32 address)
{
    /* convert the address 0x8xxxxxxx to 0xaxxxxxxx */
    if (0x80000000U == (address & 0xF0000000U))
    {
        address |= 0x20000000U;
    }
    else
    {
        /* empty */
    }

    return address;
}

/******************************************************************************/
/**
 * @brief               <get uint32 from data buffer>
 *
 * <get uint32 from data buffer> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <data (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <uint32>
 */
/******************************************************************************/
STATIC uint32 Dcm_Get4Byte(const uint8 *data)
{
    uint32 retData;

    retData = ((uint32)data[0] << 24);
    retData += ((uint32)data[1] << 16);
    retData += ((uint32)data[2] << 8);
    retData += (uint32)data[3];

    return retData;
}

/******************************************************************************/
/**
 * @brief               <set uint32 to data buffer>
 *
 * <set uint32 to data buffer> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <data (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <uint32>
 */
/******************************************************************************/
STATIC void Dcm_Set4Byte(uint8 *destData, const uint32 sourceData)
{
    destData[0] = (uint8)(sourceData >> 24);
    destData[1] = (uint8)(sourceData >> 16);
    destData[2] = (uint8)(sourceData >> 8);
    destData[3] = (uint8)sourceData;

    return;
}

/******************************************************************************/
/**
 * @brief               <check if sub function is supported in current session>
 *
 * <check if sub function is supported in current session> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <sessionTable (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>
 */
/******************************************************************************/
STATIC boolean Dcm_CheckSubFuncSession(const Dcm_SessionType sessionSupportMask)
{
    boolean ret;

    ret = Dcm_CheckSessionSupp(sessionSupportMask);

    if (FALSE == ret)
    {
        /* sub function is not supported in active session */
        Dcm_SendNcr(DCM_E_SUBFUNCTION_NOT_SUPPORT_IN_ACTIVE_SESSION);
    }
    else
    {
        /* empty */
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <check if RoutineID is supported in current session>
 *
 * <check if RoutineID is supported in current session> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <sessionTable (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>
 */
/******************************************************************************/
STATIC boolean Dcm_CheckRoutineIDSession(const Dcm_SessionType sessionSupportMask)
{
    boolean ret;

    ret = Dcm_CheckSessionSupp(sessionSupportMask);

    if (FALSE == ret)
    {
        /* RoutineID is not supported in active session */
        Dcm_SendNcr(DCM_E_CONDITIONS_NOT_CORRECT);
    }
    else
    {
        /* empty */
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <check if receive message length is correct>
 *
 * <check if receive message length is correct> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <minlength (IN),receivedLength (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>
 */
/******************************************************************************/
STATIC boolean Dcm_CheckMsgLength(const uint16 standardlength, const uint16 receivedLength)
{
    boolean ret = TRUE;

    if (receivedLength != standardlength)
    {
        ret = FALSE;

        /* service length is not correct */
        Dcm_SendNcr(DCM_E_INCORRECT_MESSAGE_LENGTH);
    }
    else
    {
        /* empty */
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <check if service is supportted in current security level>
 *
 * <check if service is supportted in current security level> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <secLevTable (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>
 */
/******************************************************************************/
STATIC boolean Dcm_CheckSecurityCondition(const Dcm_SecurityType securitySupportMask)
{
    boolean ret;

    ret = Dcm_CheckSecuritySupp(securitySupportMask);

    if (FALSE == ret)
    {
        /* security condition is not correct */
        Dcm_SendNcr(DCM_E_SECURITY_ACCESS_DENIED);
    }
    else
    {
        /* empty */
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <check if sub function is found>
 *
 * <check if sub function is found> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <find (IN),rxBuff (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>
 */
/******************************************************************************/
STATIC boolean Dcm_CheckSubFuncFind(const boolean find, const Dcm_BuffType *rxBuff)
{
    boolean ret = TRUE;

    if (FALSE == find)
    {
        if ((uint16)DCM_RX_PHY_PDU_ID == rxBuff->pduId)
        {
            /* sub function is not supported */
            Dcm_SendNcr(DCM_E_SUBFUNC_NOT_SUPPORTED);
        }
        else
        {
            /* reset service process */
            Dcm_ServiceFinish();
        }
        ret = find;
    }
    else
    {
        if (((uint16)DCM_RX_FUNC_PDU_ID == rxBuff->pduId) && (0x02u == rxBuff->pduInfo.SduDataPtr[1]) && (0x85u != rxBuff->pduInfo.SduDataPtr[0]))
        {
            /* reset service process */
            Dcm_ServiceFinish();
            ret = FALSE;
        }
        else
        {
            ret = find;
        }
    }

    return ret;
}

/******************************************************************************/
/**
 * @brief               <check if condition is correct in service>
 *
 * <check if condition is correct in service.
 * Check if Precondition is correct when changing into prog. session.> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <condition (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>
 */
/******************************************************************************/
STATIC boolean Dcm_SessionChangeConditionCheck(Dcm_SessionType sessionValue)
{
    if ((uint8)DCM_SESSION_PROGRAMMING == sessionValue)
    {
        /* check if program condition is accepted, otherwise send NRC */
        if (FALSE == dcmDspProgram.condition)
        {
            /* condition is not correct */
            Dcm_SendNcr(DCM_E_CONDITIONS_NOT_CORRECT);
        }
        else
        {
            /* empty */
        }
    }
    else
    {
        /* empty */
    }

    return dcmDspProgram.condition;
}

/******************************************************************************/
/**
 * @brief               <check if condition is correct in service>
 *
 * <check if condition is correct in service> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <condition (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>
 */
/******************************************************************************/
STATIC boolean Dcm_ConditionCheck(void)
{
    /* defined by user, the following is an example */
    boolean condition = TRUE;

    if (FALSE == condition)
    {
        Dcm_SendNcr(DCM_E_CONDITIONS_NOT_CORRECT);
    }

    return TRUE;
}

/******************************************************************************/
/**
 * @brief               <check if voltage is too high>
 *
 * <check if voltage is too high> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <condition (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>
 */
/******************************************************************************/
STATIC boolean Dcm_HighVoltageCheck(void)
{
    boolean checkResult = TRUE;

    if (FALSE == checkResult)
    {
        Dcm_SendNcr(DCM_E_VOLTAGE_TOO_HIGH);
    }

    return checkResult;
}

/******************************************************************************/
/**
 * @brief               <check if voltage is too low>
 *
 * <check if voltage is too low> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <condition (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>
 */
/******************************************************************************/
STATIC boolean Dcm_LowVoltageCheck(void)
{
    boolean checkResult = TRUE;

    if (FALSE == checkResult)
    {
        Dcm_SendNcr(DCM_E_VOLTAGE_TOO_LOW);
    }

    return checkResult;
}

/******************************************************************************/
/**
 * @brief               <check if request is out of range>
 *
 * <check if request is out of range> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <condition (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <NONE>
 * @return              <boolean>
 */
/******************************************************************************/
STATIC boolean Dcm_CheckReqOutOfRange(const boolean find)
{
    if (FALSE == find)
    {
        /* sub function is not supported */
        Dcm_SendNcr(DCM_E_REQUEST_OUT_OF_RANGE);
    }
    else
    {
        /* empty */
    }

    return find;
}

/******************************************************************************/
/**
 * @brief               <execute generate seed>
 *
 * <execute generate seed> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <secTablePtr (IN),rxBuff (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <txBuff (IN/OUT)>
 * @return              <NONE>
 */
/******************************************************************************/
STATIC void Dcm_RequestSeed(const Dcm_SecurityRowType *secTablePtr,
                            const Dcm_BuffType *rxBuff,
                            Dcm_BuffType *txBuff)
{
    Dcm_SecurityType secLevel;

    secLevel = Dcm_GetSecurityLevel();

    /* check if seed has requested */
    if (secTablePtr->secAccessLevel == secLevel)
    {
        /* if seed has requested, seed is 0x00 */
        dcmDspSec.seed = 0UL;
    }
    else if (TRUE == dcmDspSec.seedReq)
    {
        dcmDspSec.seed = dcmLastSeed;

        FL_NvmInfo.secAccessErr++;
        if (FL_NvmInfo.secAccessErr >= (uint8)DCM_SECURITY_ATTEMPT_NUM)
        {
            Dcm_StartSecurityTimer((uint32)DCM_SECURITY_TIME);
            FL_NvmInfo.secAccessErr--;
        }
        else
        {
            /* empty */
        }
    }
    else
    {
        dcmDspSec.seedReq = TRUE;

        /* record received seed Id */
        dcmDspSec.seedIdReq = secTablePtr->reqSeedId;

        /* execute generate seed */
        (void)secTablePtr->generateSeed(&dcmDspSec.seed);
    }

    /* store this seed */
    dcmLastSeed = dcmDspSec.seed;

    /* set response message */
    txBuff->pduInfo.SduDataPtr[0] = (uint8)0x67u;
    txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
    Dcm_Set4Byte(&txBuff->pduInfo.SduDataPtr[2], dcmDspSec.seed);
    txBuff->pduInfo.SduLength = (uint8)0x06u;
    Dcm_SendRsp();

    return;
}

/******************************************************************************/
/**
 * @brief               <execute compare key>
 *
 * <execute compare key> .
 * Service ID   :       <NONE>
 * Sync/Async   :       <Synchronous>
 * Reentrancy           <Reentrant>
 * @param[in]           <secTablePtr (IN),rxBuff (IN)>
 * @param[out]          <NONE>
 * @param[in/out]       <txBuff (IN/OUT)>
 * @return              <NONE>
 */
/******************************************************************************/
STATIC void Dcm_SendKey(const Dcm_SecurityRowType *secTablePtr,
                        const Dcm_BuffType *rxBuff,
                        Dcm_BuffType *txBuff)
{
    SecM_KeyType receivedKey;
    SecM_StatusType compareStatus;

    /* check if seed has requested */
    if ((TRUE == dcmDspSec.seedReq) && (dcmDspSec.seedIdReq == secTablePtr->reqSeedId))
    {
        dcmDspSec.seedReq = FALSE;

        /* get received key */
        receivedKey = Dcm_Get4Byte(&rxBuff->pduInfo.SduDataPtr[2]);

        /* compare key */
        compareStatus = secTablePtr->compareKey(receivedKey, dcmDspSec.seed);

        /* check if compare key successful */
        if (SECM_OK == compareStatus)
        {
            /* set to requested security level */
            Dcm_SetSecurityLevel(secTablePtr->secAccessLevel);

            /* clear security access attempt num */

            /* set response message */
            txBuff->pduInfo.SduDataPtr[0] = (uint8)0x67u;
            txBuff->pduInfo.SduDataPtr[1] = rxBuff->pduInfo.SduDataPtr[1];
            txBuff->pduInfo.SduLength = (uint8)0x02u;
            Dcm_SendRsp();
        }
        else
        {
            /* set to requested security level */
            Dcm_SetSecurityLevel((uint8)DCM_SECURITY_LOCKED);

            /* compare key failed, increase security access attempt num */
            FL_NvmInfo.secAccessErr++;
            /* security access attempt num is overflow */
            if (FL_NvmInfo.secAccessErr < (uint8)DCM_SECURITY_ATTEMPT_NUM)
            {
                /* the sent key is invalid */
                Dcm_SendNcr(DCM_E_INVALID_KEY);
            }
            else
            {
                /* num of security access is exceeded */
                FL_NvmInfo.secAccessErr--;

                /* start security timer */
                Dcm_StartSecurityTimer((uint32)DCM_SECURITY_TIME);

                /* send NRC */
                Dcm_SendNcr(DCM_E_EXCEED_NUMBER_OF_ATTEMPTS);
            }
        }
    }
    else
    {
        /* seed is not sent */
        Dcm_SendNcr(DCM_E_REQUEST_SEQUENCE_ERROR);
    }

    return;
}

/*=======[E N D   O F   F I L E]==============================================*/

